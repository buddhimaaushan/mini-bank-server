// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: user.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateUser = `-- name: CreateUser :one

INSERT INTO
    users (
        first_name,
        last_name,
        username,
        nic,
        hashed_password,
        email,
        phone
    )
VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
`

type CreateUserParams struct {
	FirstName      string `db:"first_name" json:"first_name"`
	LastName       string `db:"last_name" json:"last_name"`
	Username       string `db:"username" json:"username"`
	Nic            string `db:"nic" json:"nic"`
	HashedPassword string `db:"hashed_password" json:"hashed_password"`
	Email          string `db:"email" json:"email"`
	Phone          string `db:"phone" json:"phone"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, CreateUser,
		arg.FirstName,
		arg.LastName,
		arg.Username,
		arg.Nic,
		arg.HashedPassword,
		arg.Email,
		arg.Phone,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Nic,
		&i.HashedPassword,
		&i.PasswordChangedAt,
		&i.Email,
		&i.IsEmailVerified,
		&i.EmailChangedAt,
		&i.Phone,
		&i.IsPhoneVerified,
		&i.PhoneChangedAt,
		&i.AccStatus,
		&i.CustomerRank,
		&i.IsAnEmployee,
		&i.IsACustomer,
		&i.Role,
		&i.Department,
		&i.CreatedAt,
	)
	return i, err
}

const DeleteUser = `-- name: DeleteUser :one

DELETE FROM users WHERE id = $1:: BIGINT RETURNING id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
`

func (q *Queries) DeleteUser(ctx context.Context, dollar_1 int64) (User, error) {
	row := q.db.QueryRow(ctx, DeleteUser, dollar_1)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Nic,
		&i.HashedPassword,
		&i.PasswordChangedAt,
		&i.Email,
		&i.IsEmailVerified,
		&i.EmailChangedAt,
		&i.Phone,
		&i.IsPhoneVerified,
		&i.PhoneChangedAt,
		&i.AccStatus,
		&i.CustomerRank,
		&i.IsAnEmployee,
		&i.IsACustomer,
		&i.Role,
		&i.Department,
		&i.CreatedAt,
	)
	return i, err
}

const GetAllUsersAsc = `-- name: GetAllUsersAsc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
FROM users
ORDER BY
    first_name ASC,
    last_name ASC,
    username ASC
LIMIT $1
OFFSET $2
`

type GetAllUsersAscParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAllUsersAsc(ctx context.Context, arg GetAllUsersAscParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetAllUsersAsc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAllUsersDesc = `-- name: GetAllUsersDesc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
FROM users
ORDER BY
    first_name ASC,
    last_name ASC,
    username ASC
LIMIT $1
OFFSET $2
`

type GetAllUsersDescParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAllUsersDesc(ctx context.Context, arg GetAllUsersDescParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetAllUsersDesc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAllUsersOrderByIDAsc = `-- name: GetAllUsersOrderByIDAsc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at FROM users ORDER BY id ASC LIMIT $1 OFFSET $2
`

type GetAllUsersOrderByIDAscParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAllUsersOrderByIDAsc(ctx context.Context, arg GetAllUsersOrderByIDAscParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetAllUsersOrderByIDAsc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAllUsersOrderByIDDesc = `-- name: GetAllUsersOrderByIDDesc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at FROM users ORDER BY id DESC LIMIT $1 OFFSET $2
`

type GetAllUsersOrderByIDDescParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAllUsersOrderByIDDesc(ctx context.Context, arg GetAllUsersOrderByIDDescParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetAllUsersOrderByIDDesc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserByID = `-- name: GetUserByID :one

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, GetUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Nic,
		&i.HashedPassword,
		&i.PasswordChangedAt,
		&i.Email,
		&i.IsEmailVerified,
		&i.EmailChangedAt,
		&i.Phone,
		&i.IsPhoneVerified,
		&i.PhoneChangedAt,
		&i.AccStatus,
		&i.CustomerRank,
		&i.IsAnEmployee,
		&i.IsACustomer,
		&i.Role,
		&i.Department,
		&i.CreatedAt,
	)
	return i, err
}

const GetUserByUsername = `-- name: GetUserByUsername :one

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at FROM users WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, GetUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Nic,
		&i.HashedPassword,
		&i.PasswordChangedAt,
		&i.Email,
		&i.IsEmailVerified,
		&i.EmailChangedAt,
		&i.Phone,
		&i.IsPhoneVerified,
		&i.PhoneChangedAt,
		&i.AccStatus,
		&i.CustomerRank,
		&i.IsAnEmployee,
		&i.IsACustomer,
		&i.Role,
		&i.Department,
		&i.CreatedAt,
	)
	return i, err
}

const GetUsersByAccStatusAsc = `-- name: GetUsersByAccStatusAsc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
FROM users
WHERE acc_status = $1
ORDER BY
    first_name ASC,
    last_name ASC,
    username ASC
LIMIT $1
OFFSET $2
`

type GetUsersByAccStatusAscParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetUsersByAccStatusAsc(ctx context.Context, arg GetUsersByAccStatusAscParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetUsersByAccStatusAsc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersByAccStatusDesc = `-- name: GetUsersByAccStatusDesc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
FROM users
WHERE acc_status = $1
ORDER BY
    first_name DESC,
    last_name DESC,
    username DESC
LIMIT $1
OFFSET $2
`

type GetUsersByAccStatusDescParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetUsersByAccStatusDesc(ctx context.Context, arg GetUsersByAccStatusDescParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetUsersByAccStatusDesc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersByCustRankAsc = `-- name: GetUsersByCustRankAsc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
FROM users
WHERE customer_rank = $1
ORDER BY
    first_name ASC,
    last_name ASC,
    username ASC
LIMIT $1
OFFSET $2
`

type GetUsersByCustRankAscParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetUsersByCustRankAsc(ctx context.Context, arg GetUsersByCustRankAscParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetUsersByCustRankAsc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersByCustRankDesc = `-- name: GetUsersByCustRankDesc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
FROM users
WHERE customer_rank = $1
ORDER BY
    first_name DESC,
    last_name DESC,
    username DESC
LIMIT $1
OFFSET $2
`

type GetUsersByCustRankDescParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetUsersByCustRankDesc(ctx context.Context, arg GetUsersByCustRankDescParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetUsersByCustRankDesc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersByPatternAndAccStatusAsc = `-- name: GetUsersByPatternAndAccStatusAsc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
FROM users
WHERE (
        first_name LIKE $3:: text
        OR last_name LIKE $3:: text
        OR username LIKE $3:: text
        OR nic LIKE $3:: text
        OR email LIKE $3:: text
        OR phone LIKE $3:: text
        OR role LIKE $3:: text
        OR department LIKE $3:: text
    )
    AND (
        acc_status = $4
        OR acc_status = $5
        OR acc_status = $6
        OR acc_status = $7
    )
ORDER BY
    first_name ASC,
    last_name ASC,
    username ASC
LIMIT $1
OFFSET $2
`

type GetUsersByPatternAndAccStatusAscParams struct {
	Limit          int32  `db:"limit" json:"limit"`
	Offset         int32  `db:"offset" json:"offset"`
	StrPattern     string `db:"str_pattern" json:"str_pattern"`
	StatusActive   Status `db:"status_active" json:"status_active"`
	StatusInactive Status `db:"status_inactive" json:"status_inactive"`
	StatusDeleted  Status `db:"status_deleted" json:"status_deleted"`
	StatusHolded   Status `db:"status_holded" json:"status_holded"`
}

func (q *Queries) GetUsersByPatternAndAccStatusAsc(ctx context.Context, arg GetUsersByPatternAndAccStatusAscParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetUsersByPatternAndAccStatusAsc,
		arg.Limit,
		arg.Offset,
		arg.StrPattern,
		arg.StatusActive,
		arg.StatusInactive,
		arg.StatusDeleted,
		arg.StatusHolded,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersByPatternAndAccStatusDesc = `-- name: GetUsersByPatternAndAccStatusDesc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
FROM users
WHERE (
        first_name LIKE $3:: text
        OR last_name LIKE $3:: text
        OR username LIKE $3:: text
        OR nic LIKE $3:: text
        OR email LIKE $3:: text
        OR phone LIKE $3:: text
        OR role LIKE $3:: text
        OR department LIKE $3:: text
    )
    AND (
        acc_status = $4
        OR acc_status = $5
        OR acc_status = $6
        OR acc_status = $7
    )
ORDER BY
    first_name DESC,
    last_name DESC,
    username DESC
LIMIT $1
OFFSET $2
`

type GetUsersByPatternAndAccStatusDescParams struct {
	Limit          int32  `db:"limit" json:"limit"`
	Offset         int32  `db:"offset" json:"offset"`
	StrPattern     string `db:"str_pattern" json:"str_pattern"`
	StatusActive   Status `db:"status_active" json:"status_active"`
	StatusInactive Status `db:"status_inactive" json:"status_inactive"`
	StatusDeleted  Status `db:"status_deleted" json:"status_deleted"`
	StatusHolded   Status `db:"status_holded" json:"status_holded"`
}

func (q *Queries) GetUsersByPatternAndAccStatusDesc(ctx context.Context, arg GetUsersByPatternAndAccStatusDescParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetUsersByPatternAndAccStatusDesc,
		arg.Limit,
		arg.Offset,
		arg.StrPattern,
		arg.StatusActive,
		arg.StatusInactive,
		arg.StatusDeleted,
		arg.StatusHolded,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersByPatternAsc = `-- name: GetUsersByPatternAsc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
FROM users
WHERE
    first_name LIKE $3:: text
    OR last_name LIKE $3:: text
    OR username LIKE $3:: text
    OR nic LIKE $3:: text
    OR email LIKE $3:: text
    OR phone LIKE $3:: text
    OR role LIKE $3:: text
    OR department LIKE $3:: text
ORDER BY
    first_name ASC,
    last_name ASC,
    username ASC
LIMIT $1
OFFSET $2
`

type GetUsersByPatternAscParams struct {
	Limit      int32  `db:"limit" json:"limit"`
	Offset     int32  `db:"offset" json:"offset"`
	StrPattern string `db:"str_pattern" json:"str_pattern"`
}

func (q *Queries) GetUsersByPatternAsc(ctx context.Context, arg GetUsersByPatternAscParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetUsersByPatternAsc, arg.Limit, arg.Offset, arg.StrPattern)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersByPatternDesc = `-- name: GetUsersByPatternDesc :many

SELECT id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
FROM users
WHERE
    first_name LIKE $3:: text
    OR last_name LIKE $3:: text
    OR username LIKE $3:: text
    OR nic LIKE $3:: text
    OR email LIKE $3:: text
    OR phone LIKE $3:: text
    OR role LIKE $3:: text
    OR department LIKE $3:: text
ORDER BY
    first_name DESC,
    last_name DESC,
    username DESC
LIMIT $1
OFFSET $2
`

type GetUsersByPatternDescParams struct {
	Limit      int32  `db:"limit" json:"limit"`
	Offset     int32  `db:"offset" json:"offset"`
	StrPattern string `db:"str_pattern" json:"str_pattern"`
}

func (q *Queries) GetUsersByPatternDesc(ctx context.Context, arg GetUsersByPatternDescParams) ([]User, error) {
	rows, err := q.db.Query(ctx, GetUsersByPatternDesc, arg.Limit, arg.Offset, arg.StrPattern)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Nic,
			&i.HashedPassword,
			&i.PasswordChangedAt,
			&i.Email,
			&i.IsEmailVerified,
			&i.EmailChangedAt,
			&i.Phone,
			&i.IsPhoneVerified,
			&i.PhoneChangedAt,
			&i.AccStatus,
			&i.CustomerRank,
			&i.IsAnEmployee,
			&i.IsACustomer,
			&i.Role,
			&i.Department,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateUser = `-- name: UpdateUser :one

UPDATE users
SET
    first_name = COALESCE(
        $1,
        first_name
    ),
    last_name = COALESCE(
        $2,
        last_name
    ),
    hashed_password = COALESCE(
        $3,
        hashed_password
    ),
    password_changed_at = COALESCE(
        $4,
        password_changed_at
    ),
    email = COALESCE($5, email),
    is_email_verified = COALESCE(
        $6,
        is_email_verified
    ),
    email_changed_at = COALESCE(
        $7,
        email_changed_at
    ),
    email = COALESCE($5, email),
    is_email_verified = COALESCE(
        $6,
        is_email_verified
    ),
    email_changed_at = COALESCE(
        $7,
        email_changed_at
    ),
    phone = COALESCE($8, phone),
    is_phone_verified = COALESCE(
        $9,
        is_phone_verified
    ),
    phone_changed_at = COALESCE(
        $10,
        phone_changed_at
    ),
    acc_status = COALESCE(
        $11,
        acc_status
    ),
    customer_rank = COALESCE(
        $12,
        customer_rank
    ),
    is_an_employee = COALESCE(
        $13,
        is_an_employee
    ),
    is_a_customer = COALESCE(
        $14,
        is_a_customer
    ),
    role = COALESCE($15, role),
    department = COALESCE(
        $16,
        department
    )
WHERE
    id = $17 RETURNING id, first_name, last_name, username, nic, hashed_password, password_changed_at, email, is_email_verified, email_changed_at, phone, is_phone_verified, phone_changed_at, acc_status, customer_rank, is_an_employee, is_a_customer, role, department, created_at
`

type UpdateUserParams struct {
	FirstName         pgtype.Text        `db:"first_name" json:"first_name"`
	LastName          pgtype.Text        `db:"last_name" json:"last_name"`
	HashedPassword    pgtype.Text        `db:"hashed_password" json:"hashed_password"`
	PasswordChangedAt pgtype.Timestamptz `db:"password_changed_at" json:"password_changed_at"`
	Email             pgtype.Text        `db:"email" json:"email"`
	IsEmailVerified   pgtype.Bool        `db:"is_email_verified" json:"is_email_verified"`
	EmailChangedAt    pgtype.Timestamptz `db:"email_changed_at" json:"email_changed_at"`
	Phone             pgtype.Text        `db:"phone" json:"phone"`
	IsPhoneVerified   pgtype.Bool        `db:"is_phone_verified" json:"is_phone_verified"`
	PhoneChangedAt    pgtype.Timestamptz `db:"phone_changed_at" json:"phone_changed_at"`
	AccStatus         NullStatus         `db:"acc_status" json:"acc_status"`
	CustomerRank      NullRank           `db:"customer_rank" json:"customer_rank"`
	IsAnEmployee      pgtype.Bool        `db:"is_an_employee" json:"is_an_employee"`
	IsACustomer       pgtype.Bool        `db:"is_a_customer" json:"is_a_customer"`
	Role              pgtype.Text        `db:"role" json:"role"`
	Department        pgtype.Text        `db:"department" json:"department"`
	ID                int64              `db:"id" json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, UpdateUser,
		arg.FirstName,
		arg.LastName,
		arg.HashedPassword,
		arg.PasswordChangedAt,
		arg.Email,
		arg.IsEmailVerified,
		arg.EmailChangedAt,
		arg.Phone,
		arg.IsPhoneVerified,
		arg.PhoneChangedAt,
		arg.AccStatus,
		arg.CustomerRank,
		arg.IsAnEmployee,
		arg.IsACustomer,
		arg.Role,
		arg.Department,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.Nic,
		&i.HashedPassword,
		&i.PasswordChangedAt,
		&i.Email,
		&i.IsEmailVerified,
		&i.EmailChangedAt,
		&i.Phone,
		&i.IsPhoneVerified,
		&i.PhoneChangedAt,
		&i.AccStatus,
		&i.CustomerRank,
		&i.IsAnEmployee,
		&i.IsACustomer,
		&i.Role,
		&i.Department,
		&i.CreatedAt,
	)
	return i, err
}
